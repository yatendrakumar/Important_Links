Beagle bone black compilation steps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://elinux.org/Building_BBB_Kernel
	For latest kernel Device tree is important so try to compile uImage with same
	Try transferring the image to the BBB via TFTP
	* https://linuxlink.timesys.com/docs/gsg/beaglebone_black

Disable tty terminal console 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* file /etc/inittab 
	Comment line : ttyDefault::respawn:-/bin/sh
	
Minicom junk character issue
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Check the settings if all Ok please change the UART cable

DMA
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://www.makelinux.net/ldd3/chp-15-sect-4
	
TFTP server setup
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Trivial File Transfer Protocol (TFTP) is an Internet software utility for transferring files 
	that is simpler to use than the File Transfer Protocol (FTP) but less capable. 
	* It is used where user authentication and directory visibility are not required.
	TFTP uses the User Datagram Protocol (UDP) rather than the Transmission Control Protocol (TCP). 
	TFTP is described formally in Request for Comments (RFC) 1350.
	* If your machine is connected to a local area network, you may be able to boot it over the network 
	from another machine, using TFTP. If you intend to boot the installation system from another machine, 
	the boot files will need to be placed in specific locations on that machine, 
	and the machine configured to support booting of your specific machine.
	* Install following packages.
		apt-get install tftpd-hpa tftp-hpa
		sudo apt-get install xinetd tftpd tftp
		sudo apt-get install tftpd-hpa
		sudo apt-get install openbsd-inetd
	* vim /etc/inetd.conf
		tftp dgram udp wait root /usr/sbin/in.tftpd /usr/sbin/in.tftpd -s /var/lib/tftpboot
    (or)
	* sudo vim /etc/default/tftpd-hpa
		RUN_DAEMON=”yes”
	* Restart deamons
		sudo /etc/init.d/openbsd-inetd restart
		sudo /etc/init.d/tftpd-hpa restart
	* Now in some other system follow the following steps
		tftp 172.16.9.59 (dest IP address)
		tftp> get test
		tftp> quit
		cat test	
	* TFTP Server Install and Setup
		Create /etc/xinetd.d/tftp and put this entry
		service tftp
		{
		protocol        = udp
		port            = 69
		socket_type     = dgram
		wait            = yes
		user            = nobody
		server          = /usr/sbin/in.tftpd
		server_args     = /tftpboot
		disable         = no
		}
		Create a folder /tftpboot this should match whatever you gave in server_args. mostly it will be tftpboot
		sudo mkdir /tftpboot
		sudo chmod -R 0777 /tftpboot
		sudo chown -R nobody /tftpboot
	* Restart the xinetd service.
		newer systems:
			sudo service xinetd restart
			older systems:
			sudo /etc/init.d/xinetd restart
			Now our tftp server is up and running.	
	* https://rechtzeit.wordpress.com/2013/01/16/tftp-boot-using-u-boot/
	
	
TFTP Boot
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* uboot tftp
	After TFTP Setup run below commands to run uImage (Beagle Bone Black)
		setenv netmask 255.255.255.0;
		setenv gatewayip 172.16.9.1;
		setenv serverip 172.16.9.58;
		setenv ipaddr 172.16.9.19;
		Set if used uImage without Device tree
			setenv bootcmd 'tftp 0x81000000  uImage; tftp 0x88000000 am335x-boneblack.dtb; bootm 0x81000000'
		Set if used uImage with Device tree		
			setenv bootcmd 'tftp 0x80200000 uImage-BBB; bootm 0x80200000'
			setenv bootargs console=ttyO0,115200n8 quiet root=/dev/mmcblk0p2 ro rootfstype=ext4 rootwait 
		boot
	* After kernel is up
		ifconfig eth0 172.16.9.19 up;
		tftp -g -r test 172.16.9.58

H/W Interrupt handle using PIC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://www.brokenthorn.com/Resources/OSDevPic.html
	* http://iakovlev.org/index.html?p=945&m=1
	* https://www.safaribooksonline.com/library/view/understanding-the-linux/0596002130/ch04s02.html
	* http://www.oreilly.com/openbook/linuxdrive3/book/ch10.pdf
	* http://www.scs.carleton.ca/sivarama/org_book/org_book_web/slides/chap_1_versions/ch20_1.pdf

Linux important topics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://linuxeco.com/
	
Cross platform kernel panic due to init (Rootfs not found or nor able to mount the sdcard)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Try adding in .config file 
		CONFIG_CMDLINE="root=/dev/mmcblk0p2 rootwait console=ttyO0,115200"
	* Copy the rootfs in proper formated and partitioned sdcard

8051: programming-external-hardware-interrupts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://what-when-how.com/8051-microcontroller/programming-external-hardware-interrupts/

Operating System tutorial
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/

Kernel docs for api and structures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* https://www.kernel.org/doc/htmldocs/ (all)
	* Linux manual pages for functions - https://manned.org/browse/arch/linux-manpages/3.14-1

Platform devices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Platform devices are devices that typically appear as autonomous (having the freedom to act independently)
	entities in the system. This includes legacy port-based devices and	host bridges to peripheral buses, and 
	most controllers integrated into system-on-chip platforms.
	* What they usually have in common is direct addressing from a CPU bus.
	* Rarely, a platform_device will be connected through a segment of some other kind of bus; but its
	registers will still be directly addressable.

	* Platform devices are given a name, used in driver binding, and 
	a list of resources such as addresses and IRQs.

		struct platform_device {
			const char	*name;
			u32		id;
			struct device	dev;
			u32		num_resources;
			struct resource	*resource;
		};

Platform drivers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Platform drivers follow the standard driver model convention, where discovery/enumeration is 
	handled outside the drivers, and drivers provide probe() and remove() methods.  
	* They support power management and shutdown notifications using the standard conventions.
	
	* Note that probe() should in general verify that the specified device hardware actually exists; 
	sometimes platform setup code can't be sure.  
	* The probing can use device resources, including clocks, and device platform_data.
	
	* Platform drivers register themselves the normal way:
		int platform_driver_register(struct platform_driver *drv);
	Or, in common situations where the device is known not to be hot-pluggable, the probe() routine 
	can live in an init section to reduce the driver's runtime memory footprint:
		int platform_driver_probe(struct platform_driver *drv,
				  int (*probe)(struct platform_device *))

legacy driver
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* A software routine used to support an older peripheral interface.

Error (DEVICE_ATTR(-error: negative width in bit-field)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* the kernel devs don't like write permissions on devices for "others"
		Therefore all DEVICE_ATTR( calls could have 0660 instead of 0666 permitions.
		
Error (fatal error: sys/types.h: No such file or directory)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* apt-file find /usr/include/sys/types.h
		Output: libc6-dev-i386: /usr/include/sys/types.h
	libc6-dev-i386 is the package I seemingly need to install
	* Cross verify that you are compiling as a module or normal c program using gcc
	gcc file_name.c will not give error

Error (function declaration isn’t a prototype)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* In C int foo() and int foo(void) are different functions. 
	int foo() accepts an arbitrary number of arguments, while int foo(void) accepts 0 arguments.
	
Errro (Undefined reference to `pow' and `floor')
	* gcc file_name.c -lm
	This will tell gcc to link your code against the math lib. Just be sure to put the flag after the objects you want to link. 

Vitual box open error (This problem came when new kernel version is compiled)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	$sudo virtualbox
	[sudo] password for yatendra: *********
	WARNING: The vboxdrv kernel module is not loaded. Either there is no module
		     available for the current kernel (4.5.2) or it failed to
		     load. Please recompile the kernel module and install it by

		       sudo /sbin/rcvboxdrv setup

		     You will not be able to start VMs until this problem is fixed.

module_param
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* To allow arguments to be passed to your module, declare the variables that will take the values of the command 
	line arguments as global and then use the module_param() macro, (defined in linux/moduleparam.h) to set the mechanism up. 
	At runtime, insmod will fill the variables with any command line arguments that are given, like insmod mymodule.ko myvariable=5.
	
	* The module_param() macro takes 3 arguments: the name of the variable, its type and permissions for the corresponding file in sysfs. 
	Integer types can be signed as usual or unsigned. 
		int myint = 3;	module_param(myint, int, 0);
	
	* If you'd like to use arrays of integers or strings see module_param_array() and module_param_string().
	Arrays are supported too, but things are a bit different now than they were in the 2.4. days. 
	To keep track of the number of parameters you need to pass a pointer to a count variable as third parameter. 
	At your option, you could also ignore the count and pass NULL instead.
		int myintarray[2]; module_param_array(myintarray, int, NULL, 0); /* not interested in count */
	* A good use for this is to have the module variable's default values set, like an port or IO address. 
	If the variables contain the default values, then perform autodetection (explained elsewhere). Otherwise, keep the current value.
	
	* Lastly, there's a macro function, MODULE_PARM_DESC(), that is used to document arguments that the module can take. 
	It takes two parameters: a variable name and a free form string describing that variable.

Input Subsystem														
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://yannik520.github.io/input_dev_framework.html (Create sysfs class entry using Kobj)
	* https://geekwentfreak-raviteja.rhcloud.com/blog/2010/06/28/create-files-in-sysfs-sysfs_create_group/
	* https://www.kernel.org/doc/Documentation/driver-model/device.txt
	* Read Documentation/kobject.txt	
		* http://lxr.free-electrons.com/source/samples/kobject/kobject-example.c
		* http://lxr.free-electrons.com/source/samples/kobject/kset-example.c
	* http://thiemonge.org/getting-started-with-uinput
	* http://www.makelinux.net/books/lkd2/ch06lev1sec3 (Registering interruput handler)
	* Read Documents on input layers docs from linux source input.txt, input-programming.txt
	* http://www4.cs.fau.de/~thoenig/thesis/thesis.pdf (Input Abstraction Layer) check out input core topic
	* Concept used in input mouse driver to continously report events with out sysfs enteries access
		Workqueue : http://www.makelinux.net/ldd3/chp-7-sect-6	
		Kernel Timer : http://www.makelinux.net/ldd3/chp-7-sect-4
	
Exported Symbols
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* When modules are loaded, they are dynamically linked into the kernel. 
		As with user-space, dynamically linked binaries can call only into external functions that are explicitly exported for use. 
		In the kernel, this is handled via special directives called EXPORT_ SYMBOL() and EXPORT_SYMBOL_GPL().

Blogspot for Kernel terms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://renjucnair.blogspot.in/

I2c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://www.oocities.org/marco_corvi/games/lkpe/i2c/i2c.htm 
	* https://learn.sparkfun.com/tutorials/i2c/all.pdf (Pdf)
	* https://learn.sparkfun.com/tutorials/i2c
	* http://www.slideshare.net/varunmahajan06/i2c-subsystem-in-linux2624
	* http://www.esacademy.com/en/library/technical-articles-and-documents/miscellaneous/i2c-bus/general-introduction/bus-arbitration.html
	* http://www.ti.com/lit/ug/sprue11c/sprue11c.pdf
	* http://www.oocities.org/marco_corvi/games/lkpe/i2c/i2c.htm
	* http://renjucnair.blogspot.in/ (I2C bus and Client driver)
	* http://www.roboard.com/Files/Reg/I2C_Registers.pdf
	* docs.lpcware.com/lpc800um/RegisterMaps/i2c/r-Register-description.html
	* http://www.nxp.com/documents/application_note/AN10148.pdf
	* http://www.slideshare.net/itembedded/raspberry-pi-linux-i2c-driver
	* http://stackoverflow.com/questions/33549211/how-to-add-i2c-devices-on-the-beaglebone-black-using-device-tree-overlays

Virtual box
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Virtual box screen size problem
		> Install few packages in your virtual box OS (Ubuntu) 
			sudo apt-get remove libcheese-gtk23
			then sudo apt-get install xserver-xorg-coreand 
			finally, sudo apt-get install -f virtualbox-guest-x11
	* Vitual Box folder sharing
		> Run Virtual Box Os 
		> Open File Browser or Explorer
		> Click on "Connect to server" (Server is nothing your host pc from where you have run virtual box)
		> Enter Server Address like "sftp://172.16.9.58/home/yatendra" (~/ is now folder to share)
		> Click on Connect and enter user name and password of the server

Kernel startup
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://henryomd.blogspot.in/2014/11/linux-kernel-startup.html

Adding A New System Service To Android
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://www.linaro.org/blog/adding-a-new-system-service-to-android-5-tips-and-how-to/
    * http://www.opersys.com/blog/extending-android-hal

Dts and Dtsi difference
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* .dts files :
		- All Board-level definitions go here
		- These files are final Device Tree
		- dtc will process the dts files into a binary for the kernel
		- specific syntax is used

	* .dtsi files :
		- SoC definitions go here
		- These files are included files
	* dtsi file is just a dts include file. It can be included in multiple dts files.
	* The linux kernel requires the entire description of the hardware, like which board it is booting(machine type), which
		all devices it is using there addresses(device/bus addresses), there interrupts numbers(irq), mfp pins
		configuration(pin muxing/gpios) also some board level information like memory size, kernel command line etc etc
		…

	* Before device tree, all these information use to be set in a huge cluster of board files. And, Information like
		command line, memory size etc use to be passed by bootloaders as part of ATAGS through register R2(ARM).
	Machine type use to be set separately in register R1(ARM). At this time each kernel compilation use to be for only one
		specific chip an a specific board.

	* So there was a long pending wish to compile the kernel for all ARM processors, and let the kernel somehow detect its
		hardware and apply the right drivers as needed just like your PC.
	* But how? On a PC, the initial registers are hardcoded, and the rest of the information is supplied by the BIOS. But
		ARM processors don’t have a BIOS. The solution chosen was device tree, also referred to as Open Firmware
		(abbreviated OF) or Flattened Device Tree (FDT). This is essentially a data structure in byte code format which
		contains information that is helpful to the kernel when booting up.
		
	* The bootloader now loads two binaries: the kernel image and the DTB.
	* DTB is the device tree blob. The bootloader passes the DTB address through R2 instead of ATAGS and R1 register is not
		required now.

Device tree links
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://elinux.org/Device_Tree
	* http://elinux.org/Device_Tree_Usage
	* https://github.com/raspberrypi/documentation/blob/master/configuration/device-tree.md
	* http://free-electrons.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf
	* https://cdn-learn.adafruit.com/downloads/pdf/introduction-to-the-beaglebone-black-device-tree.pdf

Rasberrypi
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * Compile kernel 
		# Set env 
			KERNEL=kernel7
		# Default config file
			make bcm2709_defconfig
		# compile with Cross compiler set
			make zImage  modules dtbs -j10 
		# Install module directly onto rootfs directory (ad6203a1-ec50-4f44-a1c0-e6c3dd4c9202 is just partition name)
			sudo make  ARCH=arm INSTALL_MOD_PATH=/media/ad6203a1-ec50-4f44-a1c0-e6c3dd4c9202/ modules_install
		# Copy kernel image
			sudo scripts/mkknlimg  arch/arm/boot/zImage /media/boot/kernel7.img
		#Copy device tree files
			sudo cp  arch/arm/boot/dts/*.dtb /media/boot/ 
			sudo cp  arch/arm/boot/dts/overlays/*.dtb* /media/boot/overlays/ 
			sudo cp  arch/arm/boot/dts/overlays/README /media/boot/overlays/ 
		# Deal with available source 
			rasbian-jessie for craeting partition in SD card
				dd bs=4M if=2016-03-18-raspbian-jessie.img of=/dev/sdd
			Or Work with noobs
				Create single partition and copy noobs source into that and plug into Rasp board MMC slot

    * DSI (Display serial interface) is a high-speed serial interface based on a number of (1GBits) data lanes. 
    	The total voltage swing of the data lines is only 200mV; this makes the electromagnetic noise created and power
    	consumed very low.
    * https://en.wikipedia.org/wiki/Display_Serial_Interface
    * https://wolfpaulus.com/journal/embedded/raspberrypi_boot/ (Raspberry pi boot process)
    * http://www.eizoglobal.com/library/basics/basic_understanding_of_touch_panel/
    * https://www.quora.com/How-are-mmap-ioremap-and-kmap-different (best for ioremap and mmap differnce)
    * http://www.xml.com/ldd/chapter/book/ch13.html (DMA, memmory mapping and ioremap)
    * www.waveshare.com/w/upload/8/8b/7inch-Capacitive-Touch-LCD-UserManual.pdf
    * http://sysprogs.com/VisualKernel/tutorials/raspberry/buildkernel/
    * https://www.raspberrypi.org/documentation/installation/installing-images/linux.md
    * https://www.raspberrypi.org/documentation/configuration/device-tree.md
    * https://www.raspberrypi.org/downloads/ (Default images)
    * https://github.com/raspberrypi/firmware/wiki/Mailboxes (Mail box)
    * https://github.com/raspberrypi/firmware/wiki/Accessing-mailboxes (Addresses as data: Read to understand how Video core communicates with ARM using firmware tags)
    * http://elinux.org/RPi_Framebuffer
    * https://yangqiao.wordpress.com/2015/07/05/rtems-board-support-packages-raspberry-pi-mailbox-and-framebuffer-implementation/
    * http://magicsmoke.co.za/?p=284
    * Screen Rotation
		#display_rotate=0 Normal
		display_rotate=1 90 degrees
		#display_rotate=2 180 degrees
		#NOTE: You can rotate both the image and touch interface 180º by entering lcd_rotate=2 instead
		#display_rotate=3 270 degrees
		#display_rotate=0x10000 horizontal flip
		#display_rotate=0x20000 vertical flip
	* Read about Phandle
	* http://mirrors.neusoft.edu.cn/rpi-kernel/drivers/input/touchscreen/rpi-ft5406.c (Default driver for touch screen)
	* Read touch calibration
	* http://linuxseekernel.blogspot.in/2014/05/platform-device-driver-practical.html (Convert Platform device module into kernel module)
    
OS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * https://www.safaribooksonline.com/library/view/understanding-the-linux/0596005652/ch04.html

Ext2 partition layout
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * https://www.safaribooksonline.com/library/view/understanding-the-linux/0596005652/ch18s02.html
    sudo blockdev --getbsz /dev/sda1 (Check Block size)

Beagle bone black (BBB) Link
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * https://eewiki.net/display/linuxonarm/BeagleBone+Black#BeagleBoneBlack-ARMCrossCompiler:GCC
    * http://www.slimlogic.co.uk/2011/05/omap3-sd-booting/ (Flashing image script)
    * http://elinux.org/BeagleBoardBeginners
    * https://blackfin.uclinux.org/doku.php?id=bootloaders:u-boot:testing

Ram
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://www.hardwaresecrets.com/understanding-ram-timings/
    * http://www.hardwaresecrets.com/everything-you-need-to-know-about-ddr-ddr2-and-ddr3-memories/4/
    * http://www.jariellecatbagan.com/the-theory-behind-external-ddr3-initialization-on-the-beaglebone-black/
    * https://www.physicsforums.com/threads/distance-between-memory-and-processor.733734/

IO Systems
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/13_IOSystems.html

Block Driver
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	High memory access-
		* https://www.kernel.org/doc/Documentation/vm/highmem.txt
	* http://yannik520.github.io/blkdevarch.html
	* https://www.cs.rutgers.edu/~pxk/416/notes/11-devices.html
	* http://www.makelinux.net/ldd3/chp-16-sect-2

Ram Disk
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * https://www.kernel.org/doc/Documentation/blockdev/ramdisk.txt
    * http://www.tcu-inc.com/Articles/21/Ramdisk2.html
    * https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt
    * http://yattutime.blogspot.in/2014/02/linux-boot-process.html
    Table: Comparison of ramfs and tmpfs Experimentation    Tmpfs   Ramfs
    |       Experimentation                      |      Tmpfs           |       Ramfs           |
    | Fill maximum space and continue writing    |  Will display error  | Will continue writing |
    |       Fixed Size                           |      Yes             |           No          |
    |       Uses Swap                            |      Yes             |           No          |
    |       Volatile Storage                     |      Yes             |           Yes         |

Block Driver
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* http://blog.superpat.com/2010/05/04/a-simple-block-driver-for-linux-kernel-2-6-31/
	* http://www.makelinux.net/ldd3/chp-16-sect-3

Ram Disk
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         The problem is that the maximum size of a ramdisk, more specifically of size of memory that can be accessed via the
         ramdisk driver is configured at compiletime, can be overwritten at boottime, but remains fixed once the kernel
         is loaded into memory. The default value is probably measured in Megabytes. If I recall correctly the memory
         for a ramdisk is reserved right when the driver is loaded, all ramdisks are the same size and there is are some
         16 ramdisks by default. So not even you want a ramdisk size of 16G :-)

         As stated in the other answer, tmpfs is what you want to use. Further, you won't win a lot by having your entire OS in
         a ramdisk/tmpfs. Just copy your builddir to a tmpfs and do your compiling then. You may have to ensure that all
         temporary results are written to a location thats in the tmpfs as well.

     * http://lxr.free-electrons.com/source/drivers/block/rd.c?v=2.4.37
     * https://blulin.wordpress.com/2008/11/28/tips-to-create-ramdisk-in-a-linux-system/
     * http://www.linuxjournal.com/article/2890?page=0,0

Jtag Setup
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://sysprogs.com/VisualKernel/tutorials/raspberry/jtagsetup/

Ram Disk
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * man initrd
    * https://kernel.org/doc/Documentation/blockdev/ramdisk.txt
    * http://opensourceforu.efytimes.com/2012/02/device-drivers-disk-on-ram-block-drivers/
    * http://www.vanemery.com/Linux/Ramdisk/ramdisk.html
    * https://www.ibm.com/developerworks/library/l-initrd/
    * http://www.linuxfocus.org/English/November1999/article124.html
    * http://www.jamescoyle.net/knowledge/951-the-difference-between-a-tmpfs-and-ramfs-ram-disk
    * http://www.tldp.org/HOWTO/archived/Loopback-Root-FS/Loopback-Root-FS-2.html
    * https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt

Container_of Macro
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    syntax: container_of( pointer, container_type, container_field );
    This macro takes a pointer to a filed name container_field, within a structure of type container_type, and returns a
    pointer to the containing structure .
    simply this is a convenience macro that may be used to obtain a pointer to a structure from a pointer to some other
    structure contained with in it.

Exception handling in Pipelining
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://homepage.cs.uiowa.edu/~ghosh/2-16-06.pdf

Status Register (CPSR and SPSR)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://www.heyrick.co.uk/armwiki/The_Status_register

Cortex Reference manual
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://infocenter.arm.com/help/topic/com.arm.doc.ddi0439b/DDI0439B_cortex_m4_r0p0_trm.pdf

Arm Arch A8
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * https://www.arm.com/files/pdf/ARM_Arch_A8.pdf

Risc and Cisc Arch difference
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://www.engineersgarage.com/articles/risc-and-cisc-architecture?page=3
    * http://www.engineersgarage.com/articles/risc-and-cisc-architecture?page=5 (Example of Risc  and Cisc arch)

Linux Kernel & Device Driver Programming
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://www.cs.uni.edu/~diesburg/courses/dd/calendar.html

Device model (Chapter 14 ldd)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://www.landley.net/kdocs/ols/2002/ols2002-pages-368-375.pdf
    /include/linux/device.h file to check

Driver Model (Chapter 14 ldd)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://mirror.linux.org.au/linux.conf.au/2003/papers/Patrick_Mochel/Patrick_Mochel.pdf

Copy_from_user
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://sofc.developer-works.com/article/26555983/Internal+Working+of+Copy_from_user
    * http://www.ibm.com/developerworks/library/l-kernel-memory-access/

ioctl
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://opensourceforu.efytimes.com/2011/08/io-control-in-linux/ (Imp)
    * http://www.cs.fsu.edu/~baker/devices/notes/ch6.html
    * http://www.makelinux.net/ldd3/chp-6-sect-1

Errors: Linux System Errors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html

Access Control on a Device File
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * http://www.makelinux.net/ldd3/chp-6-sect-6

Copy form and to user
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* https://www.quora.com/Linux-Kernel/How-does-copy_to_user-work
    	* https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead

        It is not true, copy_to_user, copy_from_user can in fact refer to adresses which can trigger page fault in kernel mode.
        If the page fault could not be resolved because it is invalid, it is because the access is regulated via the
        copy_to_user and copy_from_user, the kernel is able to propagate EFAULT to the user.
        So copy_to_user and copy_from_user provide protection, first it provides protection ensuring the address is a valid
        user space address and handling the page fault in case of invalid pointer sending EFAULT to user rather than crashing
        the kernel.

    * https://www.quora.com/What-does-insmod-internally-do
    
The access_ok function (access_ok( type, addr, size );)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Use the access_ok function to check the validity of the pointer in user space that you intend to access. 
		The caller provides the pointer, which refers to the start of the data block, the size of the block, and the
		type of access (whether the area is intended to be read or written).
		The function prototype is defined as: 
	* The type argument can be specified as VERIFY_READ or VERIFY_WRITE. 
		The VERIFY_WRITE symbolic also identifies whether the memory region is readable as well as writable. 
		The function returns non-zero if the region is likely accessible (though access may still result in -EFAULT). 
		This function simply checks that the address is likely in user space, not in the kernel.

The copy_to_user function (copy_to_user( to, from, n );)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* The copy_to_user function copies a block of data from the kernel into user space. 
		This function accepts a pointer to a user space buffer, a pointer to a kernel buffer, and a length defined in
		bytes. 
		The function returns zero on success or non-zero to indicate the number of bytes that weren't transferred.		
	* After checking the ability to write to the user buffer (through access_ok), the internal function __copy_to_user is
		invoked, which in turn calls __copy_from_user_inatomic (in ./linux/arch/x86/include/asm/uaccess_XX.h, where XX
		is 32 or 64 depending on architecture). 
		This function (after determining whether to perform 1, 2 or 4 byte copies) finally calls __copy_to_user_ll,
		which is where the real work is done. 
		the page tables could change at any time, requiring a the desired pages to be pinned into memory so that they
		could not be swapped out while being addressed.
		
The copy_from_user function (copy_from_user( to, from, n );)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* The copy_from_user function copies a block of data from user space into a kernel buffer. 
		it accepts a destination buffer (in kernel space), a source buffer (from user space), and a length defined in
		bytes. 
		As with copy_to_user, the function returns zero on success and non-zero to indicate a failure to copy some
		number of bytes.	
	* The function begins by checking the ability to read from the source buffer in user space (via access_ok), and then
		calls __copy_from_user and eventually __copy_from_user_ll. From here, depending on architecture, a call is made
		to copy from the user buffer to a kernel buffer with zeroing (of unavailable bytes). The optimized assembly
		functions include the ability to manage.
