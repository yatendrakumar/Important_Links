Registering an Interrupt Handler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Interrupt handlers are the responsibility of the driver managing the hardware. 
	Each device has one associated driver and, if that device uses interrupts (and most do), then that driver registers one interrupt handler.

	* Drivers can register an interrupt handler and enable a given interrupt line for handling via the function

	/* request_irq: allocate a given interrupt line */
	int request_irq(unsigned int irq,
		            irqreturn_t (*handler)(int, void *, struct pt_regs *),
		            unsigned long irqflags,
		            const char *devname,
		            void *dev_id)

	* The first parameter, irq, specifies the interrupt number to allocate. 
	For some devices, for example legacy PC devices such as the system timer or keyboard, this value is typically hard-coded. 
	For most other devices, it is probed or otherwise determined programmatically and dynamically.
	
	* The second parameter, handler, is a function pointer to the actual interrupt handler that services this interrupt. 
	This function is invoked whenever the operating system receives the interrupt. 
	Note the specific prototype of the handler function: It takes three parameters and has a return value of irqreturn_t. 
	
	* The third parameter, irqflags, might be either zero or a bit mask of one or more of the following flags:

		* SA_INTERRUPT This flag specifies that the given interrupt handler is a fast interrupt handler. 
	Historically, Linux differentiated between interrupt handlers that were fast versus slow. 
	Fast handlers were assumed to execute quickly, but potentially very often, so the behavior of the interrupt handling was 
	modified to enable them to execute as quickly as possible. 
	Today, there is only one difference: Fast interrupt handlers run with all interrupts disabled on the local processor. 
	This enables a fast handler to complete quickly, without possible interruption from other interrupts. 
	By default (without this flag), all interrupts are enabled except the interrupt lines of any running handlers,
	which are masked out on all processors. Sans the timer interrupt, most interrupts do not want to enable this flag.
		* SA_SAMPLE_RANDOM This flag specifies that interrupts generated by this device should contribute to the kernel entropy pool. 
	The kernel entropy pool provides truly random numbers derived from various random events. 
	If this flag is specified, the timing of interrupts from this device are fed to the pool as entropy. 
	Do not set this if your device issues interrupts at a predictable rate (for example, the system timer) or 
	can be influenced by external attackers (for example, a networking device). 
	On the other hand, most other hardware generates interrupts at nondeterministic times and is, therefore, a good source of entropy. 
		* SA_SHIRQ This flag specifies that the interrupt line can be shared among multiple interrupt handlers. 
		Each handler registered on a given line must specify this flag; otherwise, only one handler can exist per line.

	* The fourth parameter, devname, is an ASCII text representation of the device associated with the interrupt. 
	For example, this value for the keyboard interrupt on a PC is "keyboard". 
	These text names are used by /proc/irq and /proc/interrupts for communication with the user, which is discussed shortly.

	* The fifth parameter, dev_id, is used primarily for shared interrupt lines. 
	When an interrupt handler is freed (discussed later), dev_id provides a unique cookie to allow the removal of 
	only the desired interrupt handler from the interrupt line. 
	Without this parameter, it would be impossible for the kernel to know which handler to remove on a given interrupt line. 
	You can pass NULL here if the line is not shared, but you must pass a unique cookie if your interrupt line is shared 
	(and unless your device is old and crusty and lives on the ISA bus, there is good chance it must support sharing). 
	This pointer is also passed into the interrupt handler on each invocation.
	A common practice is to pass the driver's device structure: This pointer is unique and might be useful to have within the handlers and the Device Model.

	* On success, request_irq() returns zero. 
	A nonzero value indicates error, in which case the specified interrupt handler was not registered. 
	A common error is -EBUSY, which denotes that the given interrupt line is already in use (and either the current user or you did not specify SA_SHIRQ).

	* Note that request_irq() can sleep and therefore cannot be called from interrupt context or other situations where code cannot block. 
	It is a common mistake to call request_irq() when it is unsafe to sleep. 
	This is partly because of why request_irq() can sleep: It is indeed unclear. 
	On registration, an entry corresponding to the interrupt is created in /proc/irq.
	The function proc_mkdir() is used to create new procfs entries. This function calls proc_create() to set up the new procfs entries, 
	which in turn call kmalloc() to allocate memory.

	* Anyhow, enough of the nitty gritty. In a driver, requesting an interrupt line and installing a handler is done via request_irq():

	if (request_irq(irqn, my_interrupt, SA_SHIRQ, "my_device", dev)) {
			printk(KERN_ERR "my_device: cannot register IRQ %d\n", irqn);
			return -EIO;
	}

	* In this example, irqn is the requested interrupt line, my_interrupt is the handler, the line can be shared, the device is named "my_device," 
	and we passed dev for dev_id. On failure, the code prints an error and returns. 
	If the call returns zero, the handler has been successfully installed. 
	From that point forward, the handler is invoked in response to an interrupt. 
	It is important to initialize hardware and register an interrupt handler in the proper order to prevent the interrupt handler 
	from running before the device is fully initialized.

Freeing an Interrupt Handler:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* When your driver unloads, you need to unregister your interrupt handler and potentially disable the interrupt line. To do this, call
		void free_irq(unsigned int irq, void *dev_id)

	* If the specified interrupt line is not shared, this function removes the handler and disables the line. 
	If the interrupt line is shared, the handler identified via dev_id is removed, 
	but the interrupt line itself is disabled only when the last handler is removed.
	Now you can see why a unique dev_id is important. With shared interrupt lines, 
	a unique cookie is required to differentiate between the multiple handlers that can exist on a single line and allow free_irq() 
	to remove only the correct handler. In either case (shared or unshared), if dev_id is non-NULL, it must match the desired handler.

	* A call to free_irq() must be made from process context.
	
Reentrancy and Interrupt Handlers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	* Interrupt handlers in Linux need not be reentrant. When a given interrupt handler is executing, 
	the corresponding interrupt line is masked out on all processors, preventing another interrupt on the same line from being received. 
	Normally all other interrupts are enabled, so other interrupts are serviced, but the current line is always disabled. 
	Consequently, the same interrupt handler is never invoked concurrently to service a nested interrupt. 

